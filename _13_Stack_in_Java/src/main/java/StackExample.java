import java.util.ArrayDeque;
import java.util.Deque;
import java.util.Stack;

/**
 * Стек — это коллекция элементов, работающая по принципу "последний пришёл — первый вышел" (LIFO — Last In, First Out).
 * Это означает, что последний добавленный элемент будет первым, который будет удален.
 * <p>
 * ### Основные операции стека:
 * <p>
 * 1. Push: добавление элемента наверху стека. <p>
 * 2. Pop: удаление элемента с верха стека. <p>
 * 3. Peek: получение верхнего элемента стека без удаления его. <p>
 * 4. isEmpty: проверяет, пуст ли стек. <p>
 * 5. Search: находит индекс элемента в стеке (считая от вершины). <p>
 * - Stack: В основном используется для реализации алгоритмических задач, таких как обход дерева, анализ
 * выражений и т. д. Однако Stack синхронизирован, что делает его медленнее по сравнению с ArrayDeque.
 * <p>
 * - Deque: Более современный и рекомендуемый способ работы с стеками, так как он более эффективный и гибкий. <p>
 * ### Основные отличия Stack и Deque: <p>
 * 1. Синхронизация: <p>
 *    - Stack: Этот класс наследуется от Vector, и его методы синхронизированы. Это делает его потокобезопасным,
 *    но также усложняет использование и снижает производительность из-за лишней синхронизации. <p>
 *    - Deque: ArrayDeque (одна из реализаций интерфейса Deque) не синхронизирован, что делает его более
 *    производительным при однопоточном доступе. Если тебе нужна потокобезопасная очередность, ты можешь
 *    использовать Collections.synchronizedDeque() для создания синхронизированной версии Deque. <p>
 * 2. Гибкость: <p>
 *    - Stack: По своей сути, это специализированная структура данных, работающая только как стек (LIFO). <p>
 *    - Deque: Поддерживает обе операции (LIFO и FIFO — очередь с приоритетом первой вышла). То есть его можно
 *    использовать как стек, так и как очередь. Ты можешь добавлять и удалять элементы как с начала, так и с конца. <p>
 * 3. Методы и API: <p>
 *    - Stack: Имеет ограниченное количество методов: push(), pop(), peek(), isEmpty(), и search(). <p>
 *    - Deque: Имеет более широкий набор методов, таких как addFirst(), addLast(), removeFirst(), removeLast(),
 *    что делает его более универсальным. <p>
 * 4. Производительность: <p>
 *    - Stack: Так как он наследует от Vector, он может быть менее эффективным в использовании памяти и
 *    производительности, особенно при частых операциях добавления и удаления элементов. <p>
 *    - Deque: Не имеет накладных расходов для синхронизации (если не требуется) и предоставляет высокую
 *    производительность при операциях вставки и удаления. <p>
 * ### Почему рекомендуется использовать Deque: <p>
 * - Производительность: В большинстве случаев Deque работает быстрее, особенно в многопоточной среде без
 * необходимости в синхронизации. <p>
 * - Гибкость: Можно использовать как стек и как очередь, что делает Deque более универсальным решением. <p>
 * - Современные практики: Большинство современных Java-приложений используют коллекции из пакета java.util, и
 * Deque более актуален в этом контексте.<p>
 */
public class StackExample {
    public static void main(String[] args) {
        // 1. Использование Stack ________________________________________________________________
        Stack<Integer> stack = new Stack<>();

        // Добавление элементов в стек
        stack.push(1);
        stack.push(2);
        stack.push(3);

        System.out.println("Стек: " + stack);

        // Получение верхнего элемента без удаления
        System.out.println("Верхний элемент: " + stack.peek());

        // Удаление верхнего элемента
        System.out.println("Удаляем верхний элемент: " + stack.pop());

        System.out.println("Стек после удаления: " + stack);

        // Проверка, пуст ли стек
        System.out.println("Стек пуст? " + stack.isEmpty());

        // 1. Использование Deque ________________________________________________________________

        Deque<Integer> stackDeque = new ArrayDeque<>();

        // Добавление элементов в стек
        stackDeque.push(1);
        stackDeque.push(2);
        stackDeque.push(3);

        System.out.println("Стек: " + stackDeque);

        // Получение верхнего элемента без удаления
        System.out.println("Верхний элемент: " + stackDeque.peek());

        // Удаление верхнего элемента
        System.out.println("Удаляем верхний элемент: " + stackDeque.pop());

        System.out.println("Стек после удаления: " + stackDeque);

        // Проверка, пуст ли стек
        System.out.println("Стек пуст? " + stackDeque.isEmpty());
    }
}